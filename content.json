{"meta":{"title":"BoiceBlog","subtitle":"大鹏一日同风起，扶摇直上九万里，假使风歇时下来，亦能颠阙沧溟水","description":"大鹏一日同风起，扶摇直上九万里，假使风歇时下来，亦能颠阙沧溟水","author":"Peng zhijian","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"背包问题全解","slug":"Bag","date":"2022-07-11T09:48:26.000Z","updated":"2022-07-11T12:08:17.524Z","comments":true,"path":"posts/236f2ea1/","link":"","permalink":"http://example.com/posts/236f2ea1/","excerpt":"","text":"背包问题01背包问题有 NN 件物品和一个容量是 VV 的背包。每件物品只能使用一次。 第 ii 件物品的体积是 vivi，价值是 wiwi。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。 输入格式第一行两个整数，N，VN，V，用空格隔开，分别表示物品数量和背包容积。 接下来有 NN 行，每行两个整数 vi,wivi,wi，用空格隔开，分别表示第 ii 件物品的体积和价值。 输出格式输出一个整数，表示最大价值。 数据范围0&lt;N,V≤10000&lt;N,V≤10000&lt;vi,wi≤10000&lt;vi,wi≤1000 输入样例123454 51 22 43 44 5 输出样例：18 解题思路:123456789101112状态表示 f[i][j] 集合 表示取前i件物品，体积为j的时候能取到的最大价值 属性 max集合划分使用最后一个变化的状态也就是f[i-1]表示取前i-1件物品，这个时候如果j&gt;=v[i] 两种情况：取第i件物品，不取第i件物品，取最大值 即f[i][j] = max(f[i-1][j], f[i - 1][j - v[i]] + w[i]) 需要的是上一个状态的下的方程。 二维状态下 时间复杂度和空间复杂度均为O(NV)优化成一维： 因为需要上一个状态的数值，那么可以让体积j从大到小枚举，保证每一次使用的体积是上一次剩下的体积 一维状态下的时间复杂度没有变，但是空间复杂度被优化到O(V) 不明白如下图: code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import java.io.*;/** * Created by IntelliJ IDEA. * User: pzj * Date: 2022/7/10 * Time: 9:36 */public class Main &#123; private static final int N = 1010;// private static final int [][] f = new int[N][N]; /** * f[i][j]表示在取前i件物品，体积为j的时候能取到的最大价值 * * @param args * @throws IOException */// public static void main(String[] args) throws IOException &#123;// BufferedReader br = new BufferedReader(new InputStreamReader(System.in));// BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));// String[] s = br.readLine().split(&quot; &quot;);// int n = Integer.parseInt(s[0]);// int m = Integer.parseInt(s[1]);// // 每次输入一堆v，w值，因为对于dp来说每一次都是用一组v，w值取更新，所以可以不用数组来接收// for (int i = 1; i &lt;= n ; i++) &#123;// String[] s1 = br.readLine().split(&quot; &quot;);// int v = Integer.parseInt(s1[0]);// int w = Integer.parseInt(s1[1]);// for(int j = 0 ; j &lt;= m;j++)&#123;// f[i][j] = f[i-1][j];// if(j &gt;= v)&#123;// f[i][j] = Math.max(f[i][j], f[i-1][j-v] + w);// &#125;// &#125;// &#125;// int res = 0;// for(int i = 0 ; i &lt;= m;i++) res = Math.max(res, f[n][i]);// System.out.println(res);// br.close();// bw.close();//// &#125; private static final int [] f = new int[N]; /** * f[i]表示体积为i时物品价值的最大值 * 为了保证此时的f[i]使用的状态是上一次的状态，可以让体积从大到小进行计算，保证每一次使用的体积是上一次剩下的状态 * 此时f[m]必定为最大值 * 证明: * 如果f[k] = max_w,两种情况: * 从f[0]转移 ==&gt;f[v[0]] + w[0] == &gt; ...==&gt; f[k] * 不从f[0]转移，其实本质上是一样的f那么从f[m - k]转移，因为所有的f值初始化为0， * 那么可以通过同样的转移路径得到f[m] = f[m - k] == &gt; ..... ==&gt; f[m]和f[k]的值是一样的，所以f[m]一定是最大值 * 如果吧f[0]初始化为0,其他值初始化为负无穷，可以保证此时路径必定只能从f[0]进行转移,此时需要循环判断哪里是最大值 * @param args * @throws IOException */ public static void main(String[] args) throws IOException &#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); String[] s = br.readLine().split(&quot; &quot;); int n = Integer.parseInt(s[0]); int m = Integer.parseInt(s[1]); // 每次输入一堆v，w值，因为对于dp来说每一次都是用一组v，w值取更新，所以可以不用数组来接收 for (int i = 1; i &lt;= n ; i++) &#123; String[] s1 = br.readLine().split(&quot; &quot;); int v = Integer.parseInt(s1[0]); int w = Integer.parseInt(s1[1]); for(int j = m ; j &gt;= v;j--)&#123;// System.out.println(j - v); f[j] = Math.max(f[j], f[j-v] + w); &#125; &#125; System.out.println(f[m]); br.close(); bw.close(); &#125;&#125; 完全背包问题有 NN 种物品和一个容量是 VV 的背包，每种物品都有无限件可用。 第 ii 种物品的体积是 vivi，价值是 wiwi。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。 输入格式第一行两个整数，N，VN，V，用空格隔开，分别表示物品种数和背包容积。 接下来有 NN 行，每行两个整数 vi,wivi,wi，用空格隔开，分别表示第 ii 种物品的体积和价值。 输出格式输出一个整数，表示最大价值。 数据范围0&lt;N,V≤10000&lt;N,V≤10000&lt;vi,wi≤10000&lt;vi,wi≤1000 输入样例123454 51 22 43 44 5 输出样例：110 解题思路:1234567891011121314因为每一种物品都可以无限使用，那么完全背包问题就是在01背包问题的情况下添加一下物品的限制相当于有无数件物品，只需要判断每一次 k * v[i] &lt;= j的时候，每一次都判断f[j]以及f[j - k * v] + w * k 的最大值即可。状态表示 f[i][j] 集合 表示取前i件物品，体积为j的时候能取到的最大价值 属性 max集合划分使用最后一个变化的状态也就是f[i-1]表示取前i-1件物品，这个时候如果j&gt;=v[i] 两种情况：取第i件物品，不取第i件物品，取最大值 即f[i][j] = max(f[i-1][j], f[i - 1][j - v[i]] + w[i]) 需要的是上一个状态的下的方程。 二维状态下 时间复杂度和空间复杂度均为O(NV)优化成一维： 因为需要上一个状态的数值，那么可以让体积j从大到小枚举，保证每一次使用的体积是上一次剩下的体积 一维状态下的时间复杂度没有变，但是空间复杂度被优化到O(V) code123456789101112131415161718192021222324252627282930313233343536import java.io.*;/** * Created by IntelliJ IDEA. * User: pzj * Date: 2022/7/10 * Time: 10:24 */public class Main &#123; private static final int N = 1010; private static final int [] f = new int[N]; public static void main(String[] args) throws IOException &#123; BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); String[] s = br.readLine().split(&quot; &quot;); int n = Integer.parseInt(s[0]); int m = Integer.parseInt(s[1]); // 每次输入一堆v，w值，因为对于dp来说每一次都是用一组v，w值取更新，所以可以不用数组来接收 for (int i = 1; i &lt;= n ; i++) &#123; String[] s1 = br.readLine().split(&quot; &quot;); int v = Integer.parseInt(s1[0]); int w = Integer.parseInt(s1[1]); for(int j = m ; j &gt;= v;j--)&#123;// System.out.println(j - v); for(int k = 1; k * v&lt;= j;k++) f[j] = Math.max(f[j], f[j-k * v] + k * w); &#125; &#125; System.out.println(f[m]); br.close(); bw.close(); &#125;&#125; 多重背包问题1有 NN 种物品和一个容量是 VV 的背包。 第 ii 种物品最多有 sisi 件，每件体积是 vivi，价值是 wiwi。 求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。输出最大价值。 输入格式第一行两个整数，N，VN，V，用空格隔开，分别表示物品种数和背包容积。 接下来有 NN 行，每行三个整数 vi,wi,sivi,wi,si，用空格隔开，分别表示第 ii 种物品的体积、价值和数量。 输出格式输出一个整数，表示最大价值。 数据范围0&lt;N,V≤1000&lt;N,V≤1000&lt;vi,wi,si≤1000&lt;vi,wi,si≤100 输入样例123454 51 2 32 4 13 4 34 5 2 输出样例：110 解题思路12345~~~#### code~~~java","categories":[{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"Diary","slug":"动态规划/Diary","permalink":"http://example.com/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/Diary/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-07-11T03:04:10.874Z","updated":"2022-07-11T09:22:02.817Z","comments":true,"path":"posts/4a17b156/","link":"","permalink":"http://example.com/posts/4a17b156/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"Diary","slug":"动态规划/Diary","permalink":"http://example.com/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/Diary/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]}